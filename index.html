<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UltraVanilla Transit Router</title>
    <link href="style.css" rel="stylesheet">
    <link href="416.png" rel="icon">
    <meta property="og:image" content="./416.png">
    <meta property="og:title" content="UltraVanilla Transit Router">
    <meta name="description" content="Figure out how to get around, fast!">
    <meta property="og:description" content="Figure out how to get around, fast!">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="./data.js"></script>
</head>

<body>
    <div class="logo"><img src="416.png"></div>
    <div class="content">
        <div class="container">
            <div>
                <h1>UltraVanilla Transit Router</h1>
                <noscript>You need to enable Javascript to run the router!</noscript>
                <p>
                    This page is meant to help players, old and new, get around the server and visit other locations.
                    UVDOT, along with the <a href="https://wiki.ultravanilla.world/wiki/OPC">OPC</a> (working on <a href="https://wiki.ultravanilla.world/wiki/Outpost_Express">OPE</a>), 
                    <a href="https://niklas20114552.github.io/st-transports/">Seacrestica Transports</a> (working on UltraStar), and more, 
                    are in the process of creating transit infrastructure across the server, currently spanning just over 100KM!
                    <br>
                    More info on the transit system at large can be found <a href="/">here</a>, and a tutorial on how to use this
                    page can be viewed <a href="/">here</a>. For technical info, head to the <a href="https://github.com/GirlInPurple/uv-transit/">Github repository</a> and read the <a href="https://github.com/GirlInPurple/uv-transit/blob/master/README.md">read-me</a> file.
                    <br>
                </p>
            </div>
            <div>
                <p style="text-align: center;">
                    Version 1.0.3, Last Updated <abbr title="11th of July, 2024, at 10:23 EST/USA East">10/07/2024</abbr><br>
                    Changelog available <a href="https://github.com/GirlInPurple/uv-transit/blob/master/changelog.md">here</a>
                </p>
            </div>
            <div class="options">
                <table style="width: 350px;">
                    <tbody>
                        <tr>
                            <td><select name="from" id="from" class="in-table">
                                    <option value=undefined>Pick a location...</option>
                                </select></td>
                            <td>- From</td>
                            <td rowspan="2">
                                <button id="flip-button">Swap</button>
                            </td>
                        </tr>
                        <tr>
                            <td><select name="to" id="to" class="in-table">
                                    <option value=undefined>Pick a location...</option>
                                </select></td>
                            <td>- To</td>
                        </tr>
                    </tbody>
                </table>
                <div class="margin">
                    <details style="display: none;"><summary>Toll Preferences</summary>
                        <select name="tolls" id="tolls" class="in-table" style="width: max-content;">
                            <option value="no-preference">Do not reroute to avoid them</option>
                            <option selected value="unless-necessary">Avoid tolls unless absolutely necessary</option>
                            <option value="avoid-tolls">Avoid tolls, period.</option>
                        </select>
                        <p class="small">Even if the option to avoid tolls is set, the options below override it.</p>
                        <input type="checkbox" name="have-SeaCard" id="have-seacard"><label for="have-seacard">I have a ST SeaCard</label><br>
                        <input type="checkbox" name="have-EasyPass" id="have-easypass"><label for="have-easypass">I have a UVDOT EasyPass</label><br>
                    </details>
                    <details open><summary>Method Preferences</summary>
                        <input type="checkbox" checked name="use-warps" id="use-warps"><label for="use-warps">Use Warp Commands</label><br>
                        <input type="checkbox" checked name="use-nether" id="use-nether"><label for="use-nether">Use Nether</label><br>
                        <input type="checkbox" checked name="use-iceways" id="use-iceways"><label for="use-iceways">Use Iceways</label><br>
                        <input type="checkbox" checked name="use-pistonbolt" id="use-pistonbolt"><label for="use-pistonbolt">Use Pistonbolts</label><br>
                        <input type="checkbox" checked name="use-minecarts" id="use-minecarts"><label for="use-minecarts">Use Minecarts</label><br>
                        <input type="checkbox" checked name="use-boatways" id="use-boatways"><label for="use-boatways">Use Boatways/Waterways</label><br>
                        <input type="checkbox" checked name="use-roadways" id="use-roadways"><label for="use-roadways">Use Roadways</label><br>
                        <input type="number" placeholder="10" name="roads-as" id="roads-as" list="speedlist"><label for="roads-as">Road Speed (m/s)</label><br>
                    </details>
                    <details><summary>Experimental</summary>
                        <p class="small">
                            Check this option if you have a large crowd going to a single location. 
                            This blocks the use of certain train stations and nether highways that make cause traffic jams or be too slow if too many people use it at once.
                        </p>
                        <input type="checkbox" name="large-crowd" id="large-crowd"><label for="large-crowd">I have a Large Crowd</label><br>
                        <p class="small">
                            Warps commands like /warp olympics are still active long after the event is over. 
                            This option enables some warp commands that may or may not be disabled by the time you use them.
                        </p>
                        <input type="checkbox" name="use-seasonal" id="use-seasonal"><label for="use-seasonal">Use Seasonal Commands</label><br>
                    </details>
                    <div class="container" style="flex-direction: row;">
                        <button id="route-button">Route!</button>
                        <p style="font-size: 75%; padding: 0%; margin: 0%;">(or press Enter)</p>
                    </div>
                </div>
            </div>
            <div class="output">
                <p class="injection" id="status-injection"></p>
                <br>
                <div class="injection" id="output-injection"></div>
                <br>
                <details style="display: none;" id="nerds">
                    <summary>Stats for nerds</summary>
                    <span id="compile-time"></span><br>
                    <span id="route-time"></span><br>
                    <span id="render-time"></span><br>
                    <span id="graph-length"></span><br>
                </details>
            </div>
        </div>
    </div>
    <div class="logo">
        <div class="container footer">
            <p>
                This site is not associated with the higher ups at UltraVanilla, nor Mojang AB or Microsoft Inc. 
                All in-game towns, groups, or other locations mentioned are also their own entity and reserve the right to ask to be added or removed from this page.
                Please open a Github issue or contact DJzombiehunter in-game to have your town/group/location added/removed/modified.
                Also, this site is <a style="color:cornflowerblue;" href="https://github.com/GirlInPurple/uv-transit">open-source</a>.
            </p>
        </div>
    </div>
    <datalist id="speedlist">
        <option value="5.6">Sprinting (5.6)</option>
        <option value="4.3">Walking (4.3)</option>
        <option value="7">Sprint-jumping (7.0)</option>
        <option value="9.5">Average horse speed (9.5)</option>
        <option value="14">Max. horse speed (14.0)</option>
    </datalist>
    <script>
        
        jQuery(() => {
            // Dropdowns
            ["from","to"].forEach((eleName) => {
                let ele = $(`#${eleName}`)

                for (townName in places) {
                    ele.append('<option class="' + places[townName] + '" value="' + townName + '">' + townName + '</option>')
                }

                ele.on("change", () => {
                    console.debug(`Set ${eleName} to ${ele.val()} in LocalStorage`)
                    localStorage.setItem(eleName, ele.val())
                })

                ele.val(localStorage.getItem(eleName))
            })
            // Toggle for if Roadways are on
            $("#use-roadways").on("change", () => {
                let ele = $("#roads-as")
                if ($("#use-roadways").is(":checked")) {
                    ele.attr("disabled", false)
                } else {
                    ele.attr("disabled", true)
                }
            })
            // Flip the to-from selections
            $("#flip-button").on("click", () => {
                let from = $("#from").val()
                let to = $("#to").val()
                $("#from").val(to)
                $("#to").val(from)
            })
            // If Pressed, route()
            $("#route-button").on("click", () => {
                route()
            })
            // If Enter, route()
            $(this).on("keypress", (event) => {
                if (event.key === "Enter") {
                    route()
                }
            })
            // Set boilerplate status text
            $("#status-injection").text("No route has been calculated yet")
        })

        const route = () => {

            /**
             * Gets the speeds of all the methods of transit.
             * 
             * @returns {{iceways: number, pistonbolts: number, railways: number, boatways: number, roadways: number|Error, walkways: number}}
            */
            const getSpeeds = () => {
                return {
                    iceways: 70, // Boat go zoom
                    pistonbolts: 50, // Estimated speed of a well built pistonbolt. May need adjusting
                    railways: 8, // Maximum speed of a minecart
                    boatways: 8, // Maximum speed of a boat
                    roadways: ($("#roads-as").val() === "") ? 10 : parseFloat($("#roads-as").val()),
                    walkways: 6.5, // Speed of walking, also the speed used by Tolls
                }
            } 

            /**
             * Compiles the human-readable data into a node graph that the routing function can read from.
             * 
             * @param {string} tollMode
             * @param {boolean} useWarps
             * @param {boolean} useNether
             * @param {boolean} useIceway
             * @param {boolean} usePistonbolt
             * @param {boolean} useRailway
             * @param {boolean} useBoatway
             * @param {boolean} useRoadway
             * @param {boolean} useSeasonal
             * 
             * @return {{processedGraph: {}, renderGraph: {}}}
            */
            const compileRoutingGraph = (
                tollMode,
                useWarps,
                useNether,
                useIceway,
                usePistonbolt,
                useRailway,
                useBoatway,
                useRoadway,
                useSeasonal
            ) => {
                const methods = getSpeeds()
                /**
                 * Adds data to the output graphs.
                 * 
                 * @param {any} node
                 * @param {string} name
                 * @param {number} set
                 * @param {any} graph
                 * @param {string} nodeKey
                 * @param {any} routes
                */
                const setGraphs = (node, name, set, graph, nodeKey, routes) => {
                    try {
                        if (node[name] > set || node[name] === undefined) {
                            node[name] = set // Node Graph, for Pathing
                            if (name !== nodeKey) {
                                graph[nodeKey][name] = routes // Render Graph, for Rendering
                            }
                        }
                    } catch (error) {
                        console.error(node, name, set, graph, nodeKey, routes, error)
                    }
                }
                /**
                 * Calculate the weight for this route, and if the weight it in invalid number fix it by setting it to 0.
                 * 
                 * @param {number} locationRoute
                 * 
                 * @returns {number}
                */
                const weightCorrection = (locationRoute) => {
                    let weight = 0
                    try {
                        weight = locationRoute[1]/methods[methodKey]
                        if (weight === Infinity | weight === NaN) {
                            weight = 0
                        }
                    } finally {
                        return weight
                    }
                }
                /**
                 * Check if this method is enabled or not.
                 * 
                 * @param {string} methodKey
                 * 
                 * @returns {boolean}
                */
                const isMethodEnabled = (methodKey) => {
                    switch (methodKey) {
                        case "roadways":
                            if (useRoadway) return true
                            else return false
                        case "iceways":
                            if (useIceway) return true
                            else return false
                        case "pistonbolts":
                            if (usePistonbolt) return true
                            else return false
                        case "railways":
                            if (useRailway) return true
                            else return false
                        case "boatways":
                            if (useBoatway) return true
                            else return false
                        case "walkways":
                            return true
                        default:
                            throw new RangeError(`This method (${methodKey}) is unvalid!`)
                    }
                }
                /**
                 * Check if this route has a toll or not.
                 * 
                 * @param {any} locationRoute
                 * 
                 * @returns {[boolean, string, number, string, number]}
                */
                const isMethodToll = (locationRoute) => {
                    if (locationRoute[2] !== undefined) {
                        let toll = locationRoute[2]
                        return [
                            true,
                            toll.currency,
                            toll.price,
                            toll.pass,
                            toll.passPrice
                        ]
                    } else {
                        return [
                            false,
                            "barrier",
                            0,
                            "nullcard",
                            0
                        ]
                    }
                }
                
                let outputNodeGraph = {}
                let outputRenderGraph = {}

                const compileGraph = (routes, routeKey) => {
                    for (let nodeKey in routes) {
                        const node = routes[nodeKey]
                        console.debug("Begin New Compilation", nodeKey, node)
                        let nodeRoutes = {}
                        outputRenderGraph[nodeKey] = {}

                        for (methodKey in node[1]) {
                            if (isMethodEnabled(methodKey)) {
                                const method = node[1][methodKey]
                                console.debug(method, node[1][methodKey])
                                for (let routeKey in method) {
                                    const locationRoute = method[routeKey]

                                    // "Infinity" weight is technically possible, avoid that.
                                    const weight = weightCorrection(locationRoute)

                                    // Handle tolls, currently disabled
                                    /*
                                    let tolls = isMethodToll(locationRoute)
                                    console.log("Before Toll Checks", tolls)
                                    if (tolls[0]) {
                                        if (tollMode === "avoid-tolls") {
                                            continue
                                        } else
                                        if (tollMode === "unless-necessary") {
                                            if ($(`#have-${tolls[3]}`)) {   // Checks if the card is whitelisted
                                                locationRoute[0] *= 4       // If not, nuke the weight
                                            }
                                        }
                                    }
                                    console.log("After Toll Checks", tolls)
                                    */

                                    // Handle adding to the graphs
                                    setGraphs(nodeRoutes, routeKey, weight, outputRenderGraph, nodeKey, [locationRoute[0], methodKey])
                                    console.debug(`"${nodeKey}"'s ${methodKey} route to "${routeKey}" is ${locationRoute[1]} meters. Weight of ${weight}.`)
                                }
                            }
                        }

                        if (useWarps) {
                            setGraphs(nodeRoutes, "Outpost", 0, outputRenderGraph, nodeKey, [["Outpost Warp"],"warp"])          // /o
                            setGraphs(nodeRoutes, "New Spawn", 0, outputRenderGraph, nodeKey, [["New Spawn Warp"],"warp"])      // /s
                            setGraphs(nodeRoutes, "Old Spawn", 0, outputRenderGraph, nodeKey, [["Old Spawn Warp"],"warp"])      // /os
                        }

                        if (useSeasonal) {
                            setGraphs(nodeRoutes, "Solitude", 0, outputRenderGraph, nodeKey, ["Olympics Warp"])                 // /warp olympics
                        }

                        // Finishing up this iteration
                        outputNodeGraph[nodeKey] = [node[0],nodeRoutes]
                        console.debug(`"${nodeKey}" compiled successfully`)
                    }
                }

                console.debug("method values: ", methods)
                console.debug(useWarps,useNether,useIceway,usePistonbolt,useRailway,useBoatway,useRoadway)

                compileGraph(routes)

                return {
                    processedGraph: outputNodeGraph,
                    renderGraph: outputRenderGraph
                }
            }

            /**
             * The router function, handles everything related to pathing.
             * 
             * @returns {{route: string[], graph: [any, any], path: any|null, error: [bool, string|null], routingTime: number, graphingTime: number}}
             */
            const internalRoute = () => {

                /**
                 * @returns {{path: string[], pathTook: any|null, reachable: boolean, reason: string|null}}
                */
                const aStar = (graph, startNode, goalNode) => {

                    function reconstructPath(cameFrom, current) {
                        let totalPath = [current]
                        while (current in cameFrom) {
                            current = cameFrom[current]
                            totalPath.unshift(current)
                        }
                        return totalPath
                    }

                    function heuristic(node, goal) {
                        return Math.hypot(goal[0][0] - node[0][0], goal[0][1] - node[0][1])
                    }

                    class Queue {
                        constructor() {
                            this.nodes = []
                        }

                        enqueue(priority, key) {
                            this.nodes.push({ key, priority })
                            this.sort()
                        }

                        dequeue() {
                            return this.nodes.shift()
                        }

                        sort() {
                            this.nodes.sort((a, b) => a.priority - b.priority)
                        }

                        isEmpty() {
                            return !this.nodes.length
                        }
                    }

                    console.debug(graph, startNode, goalNode)
                    if (jQuery.isEmptyObject(graph) || startNode === null || goalNode === null) {
                        return { 
                            path: [], 
                            pathTook: null, 
                            reachable: false, 
                            reason: "The routing data was bad. This most likely means you didn\'t choose a start/end destination." 
                        }
                    }

                    let openSet = new Queue()
                    openSet.enqueue(0, startNode)

                    let cameFrom = {}
                    let gScore = {}
                    let fScore = {}

                    for (let node in graph) {
                        gScore[node] = Infinity
                        fScore[node] = Infinity
                    }

                    gScore[startNode] = 0
                    fScore[startNode] = heuristic(startNode, goalNode)

                    console.debug("gScore", gScore)
                    console.debug("fScore", fScore)
                    console.debug("cameFrom", cameFrom)
                    console.debug("openSet.nodes", openSet.nodes)
                    console.debug("nodeGraph", graph)

                    while (!openSet.isEmpty()) {
                        let current = openSet.dequeue().key

                        if (current === goalNode) {
                            return { 
                                path: reconstructPath(cameFrom, current), 
                                pathTook: cameFrom, 
                                reachable: true, 
                                reason: null }
                        }

                        console.debug(current, graph[current])
                        for (let neighbor in graph[current][1]) {
                            let tentative_gScore = gScore[current] + graph[current][1][neighbor]
                            console.debug(neighbor, tentative_gScore < gScore[neighbor])

                            if (tentative_gScore < gScore[neighbor]) {
                                cameFrom[neighbor] = current
                                gScore[neighbor] = tentative_gScore
                                fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goalNode)
                                openSet.enqueue(fScore[neighbor], neighbor)
                            }
                        }
                    }

                    console.error('This route is impossible to complete. This most likely means you chose options in differing regions (Outpost and New Spawn are disconnected from Old Spawn), or your allowed methods are too restrictive.')
                    return { 
                        path: [], 
                        pathTook: null, 
                        reachable: false, 
                        reason: "This route is impossible to complete. This most likely means you chose options in differing regions (Outpost and New Spawn are disconnected from Old Spawn), your allowed methods are too restrictive, or the locations are not on the network yet." 
                    }
                }

                let beginGraphPreprocess = performance.now()
                let { processedGraph, renderGraph } = compileRoutingGraph(
                    $("#tolls").val(),
                    $("#use-warps").is(":checked"),
                    $("#use-nether").is(":checked"),
                    $("#use-iceways").is(":checked"),
                    $("#use-pistonbolt").is(":checked"),
                    $("#use-minecarts").is(":checked"),
                    $("#use-boatways").is(":checked"),
                    $("#use-roadways").is(":checked"),
                    $("#use-seasonal").is(":checked")
                )
                let graphProcessTime = performance.now() - beginGraphPreprocess


                let beginAStarFn = performance.now()
                let { 
                    path, 
                    pathTook, 
                    reachable, 
                    reason 
                } = aStar(
                    processedGraph,
                    $("#from").val(),
                    $("#to").val()
                )
                let AStarFnTime = performance.now() - beginAStarFn

                return {
                    route: path,
                    graph: [processedGraph, renderGraph],
                    path: pathTook,
                    error: [reachable, reason],
                    routingTime: AStarFnTime,
                    graphingTime: graphProcessTime
                }
            }
            
            /**
             * The rendering function, handles all the rendering of the routing output.
             * 
             * @param {string[]} route
             * @param {[any, any]} graph
             * @param {[bool, string|null]} error
             * @param {number} graphingTime
             * @param {number} routingTime
            */
            const renderRoute = (route, graph, error, graphingTime, routingTime) => {
                /**
                 * The numbers in data.js are in meters, or blocks, 
                 * so getting the distance between locations is very easy by doing this.
                 * 
                 * @param {string} from
                 * @param {string} to
                 * 
                 * @returns {number} the number of blocks between two adjacent nodes
                */
                const getDistanceBetween = (from, to) => {
                    let searchData = routes[from][1]
                    for (prop in searchData) {
                        let locationData = searchData[prop]
                        if (locationData[to] !== undefined) {
                            return locationData[to][1]
                        }
                    }
                    // Past this point assume this is a warp and calculate the real distance
                    return Math.hypot(routes[from][0][0] - routes[to][0][0], routes[from][0][1] - routes[to][0][1])
                }
                /**
                 * Gets the total distance of the route. 
                 * 
                 * @param {string[]} route
                 * 
                 * @returns {number}
                */
                const cascadeDistanceBetween = (route) => {
                    let totalDistance = 0
                    route.forEach((location, index, array) => {
                        if ((index+1) < array.length) {
                            totalDistance += getDistanceBetween(location, array[index+1])
                        }
                    })
                    return totalDistance
                }
                /**
                 * ! TODO: broken due to it relying on getDistanceBetween()
                 * 
                 * Gets the total distance of the route. 
                 * 
                 * @param {string[]} route
                 * 
                 * @returns {number[]}
                */
                const perStopDistanceBetween = (route) => {
                    let totalDistance = []
                    route.forEach((location, index, array) => {
                        if ((index+1) < array.length) {
                            totalDistance.push(getDistanceBetween(location, array[index+1]))
                        }
                    })
                    return totalDistance
                }
                /**
                 * Gets the number of seconds between 2 locations
                 * 
                 * @param {string} from
                 * @param {string} to
                 * @param {[any, any]} graph
                 * 
                 * @returns {number}
                */
                const getTimeBetween = (from, to, graph) => {
                    let searchData = graph[0][from][1]
                    if (searchData[to] !== undefined) {
                        return searchData[to]
                    } else {
                        return 0
                    }
                }
                /**
                 * Gets the number of seconds along a path
                 * 
                 * @param {string[]} route
                 * @param {[any, any]} graph
                 * 
                 * @returns {number}
                */
                const cascadeTimeBetween = (route, graph) => {
                    let totalTime = 0
                    route.forEach((location, index, array) => {
                        if ((index+1) < array.length) {
                            totalTime += getTimeBetween(location, array[index+1], graph)
                        }
                    })
                    return totalTime
                }
                /**
                 * Gets the line/road name between two points, and what type of method it is.
                 * 
                 * @param {string} from
                 * @param {string} to
                 * @param {[any, any]} graph
                 * 
                 * @returns {[string[],string]|undefined}
                */
                const getLineBetween = (from, to, graph) => {
                    if (graph[1][from][to] !== undefined) {
                        return [
                            graph[1][from][to][0],
                            graph[1][from][to][1]
                        ]
                    } else {
                        return undefined
                    }
                }
                /**
                 * Returns a nested list containing all the nodes on different lines on the route.
                 * 
                 * @param {string[]} route
                 * @param {[any, any]} graph
                 * 
                 * @returns {[[string[],[string[],string]]]}
                */
                const cascadeLinesBetween = (route, graph) => {
                    let lineSections = []
                    route.forEach((location, index, array) => {
                        if (index+1 < array.length) {
                            let line = getLineBetween(array[index],array[index+1], graph)
                            if (
                                lineSections.length > 0 &&
                                line !== undefined &&
                                // i hate this, but it will do.
                                line[0][0] === lineSections[lineSections.length-1][1][0][0] &&
                                line[0][1] === lineSections[lineSections.length-1][1][0][1] &&
                                line[0][2] === lineSections[lineSections.length-1][1][0][2]
                            ) {
                                lineSections[lineSections.length-1][0].push(array[index+1])
                            } else {
                                lineSections.push([
                                    [array[index],array[index+1]],
                                    line
                                ])
                            }
                        }
                    })
                    return lineSections
                }
                /**
                 * Returns the metadata for that route's primary route.
                 * 
                 * @param {string} line
                 * 
                 * @returns {{color:string,altName:string,operator:string}}
                */
                const lineMetadata = (line) => {
                    let md = methodMetadata[line]
                    return {
                        color: md.color,
                        altName: (md.altName === undefined) ? line : md.altName,
                        operator: md.operator
                    }
                }
                /**
                 * Calculates some basic totals of a route
                */
                const calculateTotals = (lines, route, graph) => {
                    let totals = {
                        distance: cascadeDistanceBetween(route),
                        time: cascadeTimeBetween(route, graph),
                        eachMethod: {},
                        tolls: {}
                    }
                    return totals
                }
                /**
                 * @param {string} nodeName
                 * @param {[any, any]} graph
                 * 
                 * @returns {string[]}
                */
                const calculateConnections = (nodeName, existingNames, graph) => {
                    let nodeData = graph[1][nodeName]
                    let exceptNames = []
                    exceptNames.push("Outpost Warp","New Spawn Warp","Old Spawn Warp")
                    existingNames.forEach((name) => {exceptNames.push(name)})
                    // Get the lines
                    let lineList = []
                    for (prop in nodeData) {
                        let routingData = nodeData[prop]
                        for (line in routingData[0]) {
                            let lineName = routingData[0][line]
                            if (!lineList.includes(lineName) && !exceptNames.includes(lineName)) {
                                lineList.push(lineName)
                            }
                        }
                    }
                    // Parse the lines
                    let elementList = []
                    for (line in lineList) {
                        let lineName = lineList[line]
                        let meta = lineMetadata(lineName)
                        elementList.push(`<span class="line" style="background-color: ${meta.color[0]}; color: ${meta.color[1]};">${meta.altName}</span>`)
                    }

                    return elementList
                }
                /**
                 * @param {number} weight - The weight of the route, also the number of seconds that route will take. (meters / meters-per-second = seconds)
                 * 
                 * @returns {string}
                */
                const secondStringify = (weight) => {
                    const minutes = Math.floor(weight / 60)
                    const seconds = weight % 60
                    const stringifiedMins = (
                        (minutes > 0 | seconds > 0) ?
                            1 == minutes ? 
                                `1 min` : 
                                `${minutes} mins` :
                            `instantly`
                    )
                    let stringifiedTime = (
                        seconds > 0 ? 
                            1 == seconds ? 
                                `${stringifiedMins}, 1 sec` : 
                                `${stringifiedMins}, ${Math.round(seconds)} secs` : 
                            stringifiedMins
                    )
                    console.debug(stringifiedMins, stringifiedTime, stringifiedTime === `Instantly`)
                    return (
                        stringifiedTime === `instantly` ?
                            `${stringifiedTime}` :
                            `in ${stringifiedTime}`
                    )
                }
                /**
                 * @param {number} meters
                 * 
                 * @returns {string}
                */
                const distanceStringify = (meters) => {
                    if (meters >= 1000) {
                        return `${(meters/1000).toFixed(2)} km`
                    } else {
                        return `${Math.round(meters)} blocks`
                    }
                }

                /**
                 * @param {{
                 *       distance: number
                 *       time: number
                 *       eachMethod: any
                 *       tolls: any
                 *  }} totals
                 * @param {[bool, string|null]} error
                 * @param {number} milliseconds
                */
                const statusRender = (totals, error, milliseconds) => {
                    console.debug(error, statusInjection, routeInjection)

                    if (error !== undefined && !error[0]) {
                        statusInjection.text(`There was an issue making the route: ${error[1]}`)
                    } else {
                        statusInjection.text(`
                            Arriving ${secondStringify(totals.time)} and traveling ${distanceStringify(totals.distance)}.
                            Route created in ${milliseconds}ms
                        `)
                    }
                }
                /**
                 * @param {[[string[],[string[],string]]]} lines
                 * @param {string[]} route
                 * @param {[any, any]} graph
                */
                const textRender = (lines, route, graph) => {
                    const flavorText = {
                        // Up to 10 texts in each category
                        keepGoing: [
                            // formatted like: "[TEXT] for (another) [DISTANCE]km (more)"
                            "Keep going",
                            "Stay on this route",
                            "Continue on",
                            "Keep holding W",
                            "Make sure you have enough food and keep going",
                            "Just keep swimming",
                        ],
                        interchange: [
                            // formatted like: "[TEXT] (the) [DESTINATION]"
                            "Make your way to",
                            "Find your way to",
                            "You should see signs for",
                            "Follow the signs for",
                        ],
                        waiting: [
                            // formatted like: "[TEXT] [DESTINATION], then [INSTRUCTIONS]"
                            "Wait until",
                            "Stare into the sun until",
                        ],
                        commandTeleport: [
                            // formatted like: "[TEXT] [DESTINATION]"
                            "Warp to",
                            "Teleport to",
                            "Wonder why the two major regions are almost 3,000km apart and teleport to",
                            "Wonder why the two major regions are just under 3,000km apart and warp to"
                        ],
                        netherTeleport: [
                            // formatted like: "[TEXT] [DESTINATION]'s Nether Portal"
                            "Walk through",
                            "Run through",
                            "Jump through",
                            "Slide through",
                            "Head through",
                        ],
                        changeTrains: [
                            // formatted like: [TEXT] to []
                            "Change trains to",
                            "Head to your connection to",
                            ""
                        ],
                        atDestination: [
                            "You will have reached your destination.",
                        ]
                    }
                    /**
                     * @param {string[]} textList
                     * @param {string} append
                     * 
                     * @returns {string} 
                    */
                    const getFlavorText = (textList, append) => {
                        let notChosen = true
                        let choice
                        while (notChosen) {
                            choice = Math.round(Math.random() * 10)
                            if (textList[choice] !== undefined) {
                                notChosen = false
                            }
                        }
                        return `${textList[choice]} ${append}`
                    }
                    /**
                     * @param {string[][]} colors
                     * @param {string[]} routeNames
                     * @param {number} distance
                     * @param {number} time
                     * @param {any} otherNodes
                     * @param {string} from
                     * @param {string} to
                     * @param {string} operator
                    */
                    const addLine = (colors, routeNames, distance, time, otherNodes, from, to, operator, method) => {
                        // Handling for the extra nodes
                        let nodeText = ""
                        let nodes = []
                        let distances = perStopDistanceBetween(route)
                        if (otherNodes.length > 0) {
                            nodeText = `<p style="padding-bottom: 5px">You will pass these locations:</p>`
                            otherNodes.forEach((node, index) => {

                                let connections = calculateConnections(node, routeNames, graph)
                                if (connections.length === 0) {
                                    nodes.push(`
                                    <p>
                                        <span class="station">${node}</span><br>
                                        ${distanceStringify(distances[index])}; ${secondStringify(distances[index]/getSpeeds()[method])}
                                    </p>
                                    <br>
                                `)
                                } else {
                                    nodes.push(`
                                    <p>
                                        <span class="station">${node}</span><br>
                                        ${distanceStringify(distances[index])}; ${secondStringify(distances[index]/getSpeeds()[method])}<br>
                                        Connections to ${connections.map(node => `${node}`).join(" ")}
                                    </p>
                                    <br>
                                `)
                                }
                            })
                        }

                        // Handling for the "Via..." section
                        let lines = []
                        routeNames.forEach((name, index) => {
                            lines.push(`
                                <span class="line" style="background-color: ${colors[index][0]}; color: ${colors[index][1]};">${name}</span>
                            `)
                        })

                        // Handling for styles
                        let borderStyle = "solid"
                        switch (method) {
                            case "warp":
                            case "portal":
                            case "walkways": 
                                borderStyle = "dotted"; 
                                break;
                            case "roadways":                 
                                borderStyle = "dashed"; 
                                break;
                            case "pistonbolt":
                            case "iceways":     
                                borderStyle = "double"; 
                                break;
                        }

                        inject.append(`
                            <div class="route-box" style="border-color: ${colors[0][0]}; border-left-style: ${borderStyle};">
                                From <span class="station">${from}</span><br>
                                Via ${lines.map(line => `${line}`).join("")}
                                <p style="color: gray; font-size: x-small;">Operated by ${operator}</p><br>
                                <p>Travel ${distance} ${time}</p>
                                <br>
                                ${nodeText}
                                ${nodes.map(node => `${node}`).join("")}
                                To <span class="station">${to}</span>
                            </div>
                            <br>
                        `)
                    }
                    
                    const inject = $("#output-injection")
                    // Add the new routes
                    lines.forEach((route) => {
                        let nodes = route[0]
                        let from = nodes[0]
                        let to = nodes[nodes.length-1]
                        let otherNodes = nodes.slice(1, nodes.length-1);

                        let lineData = []
                        route[1][0].forEach((line) => {
                            lineData.push(lineMetadata(line))
                        })

                        let colorData = []
                        lineData.forEach((line) => {
                            colorData.push(line.color)
                        })

                        addLine(
                            colorData,
                            route[1][0],
                            distanceStringify(cascadeDistanceBetween(route[0])),
                            secondStringify(cascadeTimeBetween(route[0], graph)),
                            otherNodes,
                            from,
                            to,
                            lineData[0].operator,
                            route[1][1]
                        )
                    })
                    inject.css("display","block")
                }

                const statusInjection = $("#status-injection")
                const routeInjection = $("#output-injection")
                let lines = cascadeLinesBetween(route, graph)
                let totals = calculateTotals(lines, route, graph)
                statusRender(totals, error, (graphingTime+routingTime))
                $("#output-injection").empty()
                if (lines.length !== 0) {textRender(lines, route, graph)}
            }

            /**
             * The debug rendering function, handling all performance data
             * 
             * @param {number} compileTime
             * @param {number} routingTime
             * @param {number} renderTime
             * @param {any} graph
            */
            const renderNerdy = (compileTime, routingTime, renderTime, graph) => {
                $("#compile-time").text(`compile-time: ${compileTime}ms`)
                $("#route-time").text(`route-time: ${routingTime}ms`)
                $("#render-time").text(`route-render-time: ${renderTime}ms`)
                $("#graph-length").text(`node-graph-length: ${Object.keys(graph[0]).length} nodes`)
                $("#nerds").css("display","block")
            }

            let beginRoutingFn = performance.now()

            let { route, graph, path, error, routingTime, graphingTime } = internalRoute()
            console.debug(route, graph, path, error, routingTime, graphingTime)

            let beginRenderFn = performance.now()
            renderRoute(route, graph, error, graphingTime, routingTime)
            let renderFnTime = performance.now() - beginRenderFn
            renderNerdy(graphingTime, routingTime, renderFnTime, graph)

            // Finishing up
            let routingFnTime = performance.now() - beginRoutingFn
            console.debug(`Took ${routingFnTime}ms total`)
        }
    
    </script>
</body>

</html>
